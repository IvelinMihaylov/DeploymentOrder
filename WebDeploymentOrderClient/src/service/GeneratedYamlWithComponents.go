package service

import (
	"bufio"
	"fmt"
	"math/rand"
	"os"
	"practice-repo/WebDeploymentOrderClient/src/web/RestControllers"
	"strconv"
	"strings"
	"time"
)

func GeneratedYamlWithComponents() {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("How many files to generated ?")

	input, err := reader.ReadString('\n')
	if err != nil {
		fmt.Println(err.Error())
	}
	input = strings.Trim(input, "\n")
	times, err := strconv.Atoi(input)
	if err != nil {
		fmt.Println(err.Error())
	}
	yamlCollection := autoGeneratedYamlFiles(times)

	for _, file := range yamlCollection {
		data := []byte(file)
		RestControllers.DataHttpController(data)
	}
}

func autoGeneratedYamlFiles(times int) []string {
	var yamlContainer []string
	for ; times != 0; times-- {
		matrix := fillMatrix()
		names := fillNamesOfComponents(len(matrix))
		yamlContainer = append(yamlContainer, parseGraphToYaml(names, matrix))
	}
	return yamlContainer
}

func fillMatrix() (matrix [][]bool) {

	rand.Seed(time.Now().UnixNano() * rand.Int63() * 13)

	length := 6 + rand.Intn(12-6)

	matrix = make([][]bool, length)
	for i := 0; i < length; i++ {
		matrix[i] = make([]bool, length)
	}

	for row := 0; row < len(matrix); row++ {
		for col := 0; col < len(matrix); col++ {
			if row == col {
				continue
			}
			rand.Seed(time.Now().UnixNano()*rand.Int63()*13 + int64(row)*21 + int64(col)*55 + int64(length)*34)
			if rand.Intn(10)%2 == 0 && matrix[row][col] == matrix[col][row] {
				matrix[row][col] = true
			}
		}
	}
	var dependencies = make(map[int]bool)

	for row := 0; row < len(matrix); row++ {
		for col := 0; col < len(matrix); col++ {
			if row == col {
				continue
			}
			if matrix[row][col] == true {
				dependencies[row] = true
				err := clearedCircleDependencies(row, dependencies, matrix)
				if err != nil {
					matrix[row][col] = false;
				}
			}
		}
	}
	return
}

func clearedCircleDependencies(col int, dependencies map[int]bool, matrix [][]bool) error {
	for row := 0; row < len(matrix); row++ {
			if row == col {
				continue
			}
			if matrix[row][col] == true {
				if _, ok := dependencies[row]; ok {
					return fmt.Errorf("circle dependencies")
				}
				dependencies[row] = true
				err := clearedCircleDependencies(row, dependencies, matrix)
				if err != nil {
					matrix[row][col] = false;
				}
			}
		}

	return nil
}

func fillNamesOfComponents(count int) [] string {
	var names []string
	for i := 0; i < count; i++ {
		rand.Seed(time.Now().UnixNano()*rand.Int63()*13 + int64(i)*21 + int64(count)*55)
		name := string(65 + rand.Intn(25))
		for ; contains(names, name); {
			name = string(65 + rand.Intn(25))
		}
		names = append(names, name)
	}
	return names
}

func contains(s []string, e string) bool {
	for _, a := range s {
		if strings.EqualFold(a, e) {
			return true
		}
	}
	return false
}

func parseGraphToYaml(names [] string, matrix [][]bool) string {
	var yamlText strings.Builder
	yamlText.WriteString("components:\n")
	for row := 0; row < len(matrix); row++ {
		yamlText.WriteString("  - component: " + names[row] + "\n    requires:\n")
		for col := 0; col < len(matrix[row]); col++ {
			if matrix[row][col] {
				yamlText.WriteString("      - " + names[col] + "\n")
			}
		}
	}
	fmt.Println(yamlText.String())
	return yamlText.String()
}
